### JSON 验证器

当取样器\处理器响应数据为JSON时，可通过 JSON验证器 验证响应数据是否符合预期

```yaml
testclass: json # json 验证器，用于验证json内容
field: '$.status'  # json path
expected: 200  # 期望值
rule: ==
strict: false 
```

或

```yaml
{ testclass: json, field: '$.status', expected: 200, rule: == }
```

testclass：定义验证器类型，可选值：json、JSONAssertion 、json_assertion

field：定义 验证值的 JSON PATH

expected：期望值，可以多个值

rule：验证规则，默认 ==

strict: 是否严格验证，默认否，忽略大小写匹配

### HTTP 验证器

HTTP取样器专属验证器，通常用于验证 http状态码、http response header

```yaml
testclass: http_assertion # http 验证器，用于验证http响应（状态码、header、响应消息内容）
field: status  # http响应的哪个部位 status、header[0].xxx、body
expected: 200  # 期望值
rule: ==
strict: false 
```

或

```yaml
{ testclass: http_assertion, field: status, expected: 2000, rule: == }
```

testclass：定义取样器类型，可选值：http、https、HTTPAssertion 、http_assertion

field：定义 验证值，HTTP状态码：status，响应Body：body，响应头：header[0].Content-Type

expected：期望值，可以多个值

rule：验证规则，默认 ==

strict: 是否严格验证，默认否，忽略大小写匹配

### Result 验证器

验证取样器响应结果是否符合预期

```yaml
testclass: result_assertion  # result 验证器类型
expected: 200 # 变量名称
rule: ==
strict: false 
```

或

```yaml
{ testclass: result_assertion, expected: 200, rule: ==, strict: false }
```

testclass：定义取样器类型，可选值：RegexAssertion 、regex_assertion

expected：期望值，可以多个值（仅部分验证规则生效）

rule：验证规则，默认 ==

strict: 是否严格验证，默认否，忽略大小写匹配

## 验证规则 rule

验证规则默认为 ==，验证 实际值是否与期望值一致，详细规则如下：

| 引用                                                                                               | 描述                          |
|--------------------------------------------------------------------------------------------------|-----------------------------|
| "equals", "equal", "qe", "is", "=", "==", "===", "等于", "相等"                                      | 验证实际值是否与期望值一致，数字 1.0 等同于 1  |
| "not_equals", "not_equal", "neq", "不等于", "!=", "<>", "not", "is_not"                             | 验证实际值是否与期望值不一致              |
| "equals_any", "any_equals", "equal_any", "any_equal", "eq_any", "any_eq"                         | 验证实际值是否与期望值中的任意一个值一致（忽略大小写） |
| "contains", "ct", "包含", "⊆", "contain"                                                           | 验证实际值是否包含期望值                |
| "any_contains", "contains_any", "any_contains", "contain_any"                                    | 验证实际值是否包含期望值中的任意一个值         |
| "not_contains", "not_contain", "nct", "不包含", "⊈"                                                 | 验证实际值是否不包含期望值               |
| "empty", "null", "blank", "is_empty", "is_null", "is_blank", "isEmpty", "isNull", "isBlank", "空" | 验证实际值是否为空                   |
| "is_not_empty", "is_not_null", "is_not_blank", "isNotEmpty", "isNotNull", "isNotBlank", "非空"     | 验证实际值是否非空                   |
| ">", "大于", "greater", "greater_than", "gt"                                                       | 验证实际值是否大于期望值（用于比较数字）        |
| ">=", "大于等于", "greater_or_equals", "greater_than_or_equals", "gte"                               | 验证实际值是否大于等于期望值（用于比较数字）      |
| "<", "小于", "less", "less_than", "lt"                                                             | 验证实际值是否小于期望值  （用于比较数字）      |
| "<=", "小于等于", "less_or_equals", "less_than_or_equals", "lte"                                     | 验证实际值是否小于等于期望值  （用于比较数字）    |
| "regex", "rx", "正则", "正则表达式"                                                                     | 验证实际值是否与正则表达式相匹配            |
| "same", "object", "same_object"                                                                  | 验证实际值是否与期望值一致（对象类型&属性值）     |

# 二次开发

## 验证器

当内置的提取器无法满足使用要求时，可以自行开发提取器组件

示例：

1. 当期望值需要通过比较负责的业务处理才能获取时，可通过自定义验证器实现需求

```java
// Kw 定义组件的引用关键字，以便在 testclass 中引用，默认为类名
// 为防止类名重复，建议使用 Alias
@KW({"CustomAssertion", "custom_assertion", "custom"})
public class CustomAssertion extends AbstractAssertion {

    @Override
    protected Object extractActualValue(SampleResult result) {
        // todo 实现实际值获取
        return null;
    }

}
```

通过以上代码完成自定义验证器开发后，还需要通过 SPI进行注册

1. 在工程的 resources 目录中创建目录 META-INF
2. 在 META-INF 目录中创建目录 services
3. 在 services 目录中创建文件
4. 创建 io.github.xiaomisum.ryze.core.assertion.Assertion
5. 在 io.github.xiaomisum.ryze.core.assertion.Assertion 文件中填写 自定义验证器的完整类名（含包路径）

参考[示例](../../ryze/src/main/resources/META-INF/services/io.github.xiaomisum.ryze.core.assertion.Assertion)

2. 当测试结果需要复杂的业务规则才能进行验证时，可通过自定义规则实现需求

```java

@KW({"CustomMatcher", "custom_matcher", "custom"})
public class CustomMatcher extends MatcherProxy {
    private final Object expected;
    private final boolean ignoreCase;

    public CustomMatcher(Object expected) {
        this(expected, false);
    }

    public CustomMatcher(Object expected, boolean ignoreCase) {
        this.expected = expected;
        this.ignoreCase = ignoreCase;
    }


    @Override
    public boolean matches(Object actual) {
        return Comparator.areEqual(actual, expected, ignoreCase);
    }

    @Override
    public void describeTo(Description description) {
        description.appendValue(expected);
    }
}
```

<!-- todo 这里要说明怎么注册 -->
通过以上代码完成自定义验证规则开发后，还需要通过 SPI进行注册

1. 在工程的 resources 目录中创建目录 META-INF
2. 在 META-INF 目录中创建目录 services
3. 在 services 目录中创建文件
4. 创建 org.hamcrest.Matcher
5. 在 org.hamcrest.Matcher 文件中填写 自定义验证规则的完整类名（含包路径）

参考[示例](../../ryze/src/main/resources/META-INF/services/org.hamcrest.Matcher)

